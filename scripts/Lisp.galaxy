// Lisp.galaxy
// Simple Lisp reader/evaluator for s-expression configuration
// Based on Racket-style syntax

// === SYMBOL TABLE ===

// Simple symbol table for variable definitions
const int c_maxSymbols = 100;
static string[c_maxSymbols] gv_symbolNames;
static string[c_maxSymbols] gv_symbolValues;
static int gv_symbolCount = 0;

// Function table for function definitions
const int c_maxFunctions = 50;
static string[c_maxFunctions] gv_functionNames;
static string[c_maxFunctions] gv_functionParams;  // Space-separated parameter names
static string[c_maxFunctions] gv_functionBodies;  // Body as s-expression string
static int gv_functionCount = 0;

// Recursion depth tracking
static int gv_recursionDepth = 0;
const int c_maxRecursionDepth = 100;

// Define a variable in the symbol table
void DefineVariable(string name, string value)
{
    int i;
    
    // Check if variable already exists - update it
    i = 0;
    while (i < gv_symbolCount) {
        if (gv_symbolNames[i] == name) {
            gv_symbolValues[i] = value;
            // Log("  Updated variable: " + name + " = " + value);
            return;
        }
        i = i + 1;
    }
    
    // Add new variable
    if (gv_symbolCount < c_maxSymbols) {
        gv_symbolNames[gv_symbolCount] = name;
        gv_symbolValues[gv_symbolCount] = value;
        // Log("  Defined variable: " + name + " = " + value);
        gv_symbolCount = gv_symbolCount + 1;
    }
    else {
        Log("  ERROR: Symbol table full, cannot define " + name);
    }
}

// Look up a variable in the symbol table
// Returns the value, or the original name if not found
string LookupVariable(string name)
{
    int i;
    
    i = 0;
    while (i < gv_symbolCount) {
        if (gv_symbolNames[i] == name) {
            return gv_symbolValues[i];
        }
        i = i + 1;
    }
    
    // Not found - return original name
    return name;
}

// Define a function in the function table
void DefineFunction(string name, string params, string body)
{
    int i;
    
    // Check if function already exists - update it
    i = 0;
    while (i < gv_functionCount) {
        if (gv_functionNames[i] == name) {
            gv_functionParams[i] = params;
            gv_functionBodies[i] = body;
            // Log("  Updated function: " + name + "(" + params + ")");
            return;
        }
        i = i + 1;
    }
    
    // Add new function
    if (gv_functionCount < c_maxFunctions) {
        gv_functionNames[gv_functionCount] = name;
        gv_functionParams[gv_functionCount] = params;
        gv_functionBodies[gv_functionCount] = body;
        // Log("  Defined function: " + name + "(" + params + ")");
        gv_functionCount = gv_functionCount + 1;
    }
    else {
        Log("  ERROR: Function table full, cannot define " + name);
    }
}

// Look up a function in the function table
// Returns the function index, or -1 if not found
int LookupFunction(string name)
{
    int i;
    
    i = 0;
    while (i < gv_functionCount) {
        if (gv_functionNames[i] == name) {
            return i;
        }
        i = i + 1;
    }
    
    return -1;
}

// === PARSER ===

// Find the matching closing paren for an opening paren at startPos
// Returns position of closing paren, or -1 if not found
int FindMatchingParen(string str, int startPos)
{
    int len;
    int pos;
    int depth;
    string ch;
    
    len = StringLength(str);
    pos = startPos + 1;  // Start after opening paren
    depth = 1;
    
    while (pos <= len && depth > 0) {
        ch = StringSub(str, pos, pos);
        if (ch == "(") {
            depth = depth + 1;
        }
        else if (ch == ")") {
            depth = depth - 1;
        }
        pos = pos + 1;
    }
    
    if (depth == 0) {
        return pos - 1;  // Return position of closing paren
    }
    
    return -1;  // No matching paren found
}

// Extract the Nth token from within an s-expression (0-indexed)
// s-expression should be like "(spawn 'Marine 8 3 0 90)"
// Token 0 = "spawn", Token 1 = "'Marine", Token 2 = "8", etc.
string GetSExprToken(string sexpr, int tokenIndex)
{
    int pos;
    int currentToken;
    int tokenStart;
    int tokenEnd;
    int len;
    string ch;
    
    len = StringLength(sexpr);
    
    // Skip opening paren (position 1 is '(', so start at 2)
    pos = 2;
    pos = SkipWhitespace(sexpr, pos);
    
    currentToken = 0;
    
    while (pos <= len) {
        // Skip whitespace
        pos = SkipWhitespace(sexpr, pos);
        
        if (pos > len) {
            break;
        }
        
        ch = StringSub(sexpr, pos, pos);
        
        if (ch == ")") {
            break;  // End of s-expression
        }
        
        // Found start of token
        if (currentToken == tokenIndex) {
            tokenStart = pos;
            // Check if token is a quoted string
            if (StringSub(sexpr, tokenStart, tokenStart) == "\"") {
                // Find closing quote
                tokenEnd = tokenStart + 1;
                while (tokenEnd <= len && StringSub(sexpr, tokenEnd, tokenEnd) != "\"") {
                    tokenEnd = tokenEnd + 1;
                }
                if (tokenEnd <= len) {
                    tokenEnd = tokenEnd + 1;  // Include closing quote
                }
                return StringSub(sexpr, tokenStart, tokenEnd - 1);
            }
            // Check if token is a nested s-expression
            else if (StringSub(sexpr, tokenStart, tokenStart) == "(") {
                tokenEnd = FindMatchingParen(sexpr, tokenStart);
                return StringSub(sexpr, tokenStart, tokenEnd);
            }
            else {
                tokenEnd = ReadUntilDelimiter(sexpr, tokenStart);
                return StringSub(sexpr, tokenStart, tokenEnd - 1);
            }
        }
        
        // Skip to next token
        if (StringSub(sexpr, pos, pos) == "\"") {
            // Skip quoted string
            pos = pos + 1;
            while (pos <= len && StringSub(sexpr, pos, pos) != "\"") {
                pos = pos + 1;
            }
            if (pos <= len) {
                pos = pos + 1;  // Skip closing quote
            }
        }
        else if (StringSub(sexpr, pos, pos) == "(") {
            // Skip nested s-expression
            pos = FindMatchingParen(sexpr, pos) + 1;
        }
        else {
            pos = ReadUntilDelimiter(sexpr, pos);
        }
        currentToken = currentToken + 1;
    }
    
    return "";  // Token not found
}

// Count how many tokens are in an s-expression (excluding parens)
int CountSExprTokens(string sexpr)
{
    int pos;
    int count;
    int len;
    string ch;
    
    len = StringLength(sexpr);
    pos = 2;  // Skip opening paren (position 1 is '(', start at 2)
    count = 0;
    
    while (pos <= len) {
        pos = SkipWhitespace(sexpr, pos);
        
        if (pos > len) {
            break;
        }
        
        ch = StringSub(sexpr, pos, pos);
        if (ch == ")") {
            break;
        }
        
        // Found a token
        count = count + 1;
        
        // Skip token
        if (StringSub(sexpr, pos, pos) == "\"") {
            // Skip quoted string
            pos = pos + 1;
            while (pos <= len && StringSub(sexpr, pos, pos) != "\"") {
                pos = pos + 1;
            }
            if (pos <= len) {
                pos = pos + 1;  // Skip closing quote
            }
        }
        else if (StringSub(sexpr, pos, pos) == "(") {
            // Skip nested s-expression
            pos = FindMatchingParen(sexpr, pos) + 1;
        }
        else {
            pos = ReadUntilDelimiter(sexpr, pos);
        }
    }
    
    return count;
}

// === EVALUATOR ===

// Evaluate a spawn command from s-expression
// Example: "(spawn 'Marine 8 3 0 90)"
void EvalSpawn(string sexpr, int player, point startLocation)
{
    string command;
    string unitType;
    int count;
    int offsetX;
    int offsetY;
    int facing;
    point spawnPoint;
    
    // Parse the s-expression
    command = GetSExprToken(sexpr, 0);
    
    // Log("Evaluating s-expr: " + sexpr);
    // Log("  Command: " + command);
    
    if (command != "spawn") {
        Log("  ERROR: Expected 'spawn' command, got '" + command + "'");
        return;
    }
    
    // Get unit type (with quote or variable name)
    unitType = GetSExprToken(sexpr, 1);
    
    // Remove leading quote if present, or look up variable
    if (StartsWith(unitType, "'")) {
        unitType = StringSub(unitType, 2, StringLength(unitType));
    }
    else {
        // Look up variable in symbol table
        unitType = LookupVariable(unitType);
        // Log("  Looked up variable: " + GetSExprToken(sexpr, 1) + " -> " + unitType);
    }
    
    // Parse numeric arguments (look up variables first)
    count = ParseInt(LookupVariable(GetSExprToken(sexpr, 2)));
    offsetX = ParseInt(LookupVariable(GetSExprToken(sexpr, 3)));
    offsetY = ParseInt(LookupVariable(GetSExprToken(sexpr, 4)));
    facing = ParseInt(LookupVariable(GetSExprToken(sexpr, 5)));
    
    // Calculate spawn point
    spawnPoint = PointWithOffset(startLocation, offsetX, offsetY);
    
    // Spawn based on unit type
    if (StringContains(unitType, "CommandCenter", c_stringAnywhere, c_stringNoCase)) {
        // Base spawn - ignores count and facing parameters
        // Log("  Spawning CommandCenter at (" + IntToString(offsetX) + "," + IntToString(offsetY) + ") with workers");
        SpawnBase(player, spawnPoint);
    }
    else if (StringContains(unitType, "Marine", c_stringAnywhere, c_stringNoCase)) {
        // Log("  Spawning " + IntToString(count) + " Marines at (" + IntToString(offsetX) + "," + IntToString(offsetY) + ") facing " + IntToString(facing));
        SpawnMarine(count, player, spawnPoint, facing);
    }
    else if (StringContains(unitType, "Zealot", c_stringAnywhere, c_stringNoCase)) {
        // Log("  Spawning " + IntToString(count) + " Zealots at (" + IntToString(offsetX) + "," + IntToString(offsetY) + ") facing " + IntToString(facing));
        SpawnZealot(count, player, spawnPoint, facing);
    }
}

// Evaluate a define command from s-expression
// Example: "(define m 'Marine)" or "(define (funcname params) body)"
void EvalDefine(string sexpr)
{
    string command;
    string varName;
    string varValue;
    string funcName;
    string params;
    string body;
    int bodyStart;
    int i;
    int len;
    int numParams;
    int paramIdx;
    
    // Parse the s-expression
    command = GetSExprToken(sexpr, 0);
    
    // Log("Evaluating s-expr: " + sexpr);
    // Log("  Command: " + command);
    
    if (command != "define") {
        Log("  ERROR: Expected 'define' command, got '" + command + "'");
        return;
    }
    
    // Get the second token - could be a variable name or function definition (name params)
    varName = GetSExprToken(sexpr, 1);
    
    // Check if it's a function definition: (define (funcname params) body)
    if (StartsWith(varName, "(")) {
        // Function definition: extract name and params from the s-expression
        
        // Extract function name (first token of the s-expr)
        funcName = GetSExprToken(varName, 0);
        
        // Extract parameters (remaining tokens, space-separated)
        params = "";
        numParams = CountSExprTokens(varName);
        paramIdx = 1;
        while (paramIdx < numParams) {
            if (paramIdx > 1) {
                params = params + " ";
            }
            params = params + GetSExprToken(varName, paramIdx);
            paramIdx = paramIdx + 1;
        }
        params = Trim(params);
        
        // Log("  Function definition: " + funcName + "(" + params + ")");
        
        // Get function body - token 2 onwards
        i = 2;  // Skip opening paren
        i = SkipWhitespace(sexpr, i);
        i = ReadUntilDelimiter(sexpr, i);  // Skip "define"
        i = SkipWhitespace(sexpr, i);
        
        // Skip the (funcname params) s-expression
        if (StringSub(sexpr, i, i) == "(") {
            i = FindMatchingParen(sexpr, i) + 1;
        }
        
        i = SkipWhitespace(sexpr, i);
        bodyStart = i;
        
        // Body goes to the end of the s-expression (before closing paren)
        len = StringLength(sexpr);
        body = StringSub(sexpr, bodyStart, len - 1);  // -1 to exclude closing paren
        body = Trim(body);
        
        // Log("  Function body: " + body);
        
        DefineFunction(funcName, params, body);
    }
    else {
        // Variable definition: (define var value)
        varValue = GetSExprToken(sexpr, 2);
        
        // Remove leading quote from value if present
        if (StartsWith(varValue, "'")) {
            varValue = StringSub(varValue, 2, StringLength(varValue));
        }
        
        // Define the variable
        DefineVariable(varName, varValue);
    }
}

// Evaluate arithmetic expression (+ a b) or (- a b)
int EvalArithmetic(string sexpr)
{
    string op;
    int arg1;
    int arg2;
    string arg1Str;
    string arg2Str;
    
    op = GetSExprToken(sexpr, 0);
    arg1Str = GetSExprToken(sexpr, 1);
    arg2Str = GetSExprToken(sexpr, 2);
    
    // Look up variables if needed
    arg1Str = LookupVariable(arg1Str);
    arg2Str = LookupVariable(arg2Str);
    
    arg1 = ParseInt(arg1Str);
    arg2 = ParseInt(arg2Str);
    
    if (op == "+") {
        return arg1 + arg2;
    }
    else if (op == "-") {
        return arg1 - arg2;
    }
    else if (op == "*") {
        return arg1 * arg2;
    }
    else if (op == "/") {
        if (arg2 != 0) {
            return arg1 / arg2;
        }
        return 0;
    }
    
    return 0;
}

// Evaluate comparison expression (> a b), (< a b), (= a b)
bool EvalComparison(string sexpr)
{
    string op;
    int arg1;
    int arg2;
    string arg1Str;
    string arg2Str;
    
    op = GetSExprToken(sexpr, 0);
    arg1Str = GetSExprToken(sexpr, 1);
    arg2Str = GetSExprToken(sexpr, 2);
    
    // Look up variables if needed
    arg1Str = LookupVariable(arg1Str);
    arg2Str = LookupVariable(arg2Str);
    
    arg1 = ParseInt(arg1Str);
    arg2 = ParseInt(arg2Str);
    
    if (op == ">") {
        return arg1 > arg2;
    }
    else if (op == "<") {
        return arg1 < arg2;
    }
    else if (op == "=") {
        return arg1 == arg2;
    }
    
    return false;
}

// Forward declarations for mutual recursion
void EvalExpression(string sexpr, int player, point startLocation);
void EvalLisp(string code, int player, point startLocation);

// Evaluate a begin block - evaluates multiple expressions in sequence
// Example: "(begin (spawn m 1 0 0 90) (spawn m 1 1 0 90))"
void EvalBegin(string sexpr, int player, point startLocation)
{
    int numExprs;
    int i;
    string expr;
    
    // Log("Evaluating begin block");
    
    // Count how many expressions are in the begin block
    numExprs = CountSExprTokens(sexpr);
    
    // Evaluate each expression (skip token 0 which is "begin")
    i = 1;
    while (i < numExprs) {
        expr = GetSExprToken(sexpr, i);
        // Log("  Begin expression " + IntToString(i) + ": " + expr);
        EvalExpression(expr, player, startLocation);
        i = i + 1;
    }
}

// Evaluate a log command - logs a message
// Example: "(log \"Hello World\")"
void EvalLog(string sexpr)
{
    string message;
    
    // Get the message (token 1)
    message = GetSExprToken(sexpr, 1);
    
    // Remove quotes if present
    if (StartsWith(message, "\"") && EndsWith(message, "\"")) {
        message = StringSub(message, 2, StringLength(message) - 1);
    }
    
    // Look up variable if it's not a string literal
    if (!StartsWith(GetSExprToken(sexpr, 1), "\"")) {
        message = LookupVariable(message);
    }
    
    Log(message);
}

// Evaluate an if expression: (if condition then-expr else-expr)
string EvalIf(string sexpr, int player, point startLocation)
{
    string conditionExpr;
    string thenExpr;
    string elseExpr;
    bool condition;
    int parenPos;
    int condEnd;
    int condStart;
    int thenEnd;
    int thenStart;
    int elseEnd;
    int elseStart;
    
    // Initialize
    elseExpr = "";
    
    // Token 1 is the condition (might be an s-expression like (> count 0))
    // We need to extract it properly
    
    // Find condition - skip "if" and whitespace
    parenPos = 2;  // Start after opening paren
    parenPos = SkipWhitespace(sexpr, parenPos);
    parenPos = ReadUntilDelimiter(sexpr, parenPos);  // Skip "if"
    parenPos = SkipWhitespace(sexpr, parenPos);
    
    // Extract condition (might be nested s-expr)
    if (StringSub(sexpr, parenPos, parenPos) == "(") {
        condEnd = FindMatchingParen(sexpr, parenPos);
        conditionExpr = StringSub(sexpr, parenPos, condEnd);
        parenPos = condEnd + 1;
    }
    else {
        condStart = parenPos;
        parenPos = ReadUntilDelimiter(sexpr, parenPos);
        conditionExpr = StringSub(sexpr, condStart, parenPos - 1);
    }
    
    // Evaluate condition
    condition = EvalComparison(conditionExpr);
    
    // Extract then and else expressions
    parenPos = SkipWhitespace(sexpr, parenPos);
    
    if (StringSub(sexpr, parenPos, parenPos) == "(") {
        thenEnd = FindMatchingParen(sexpr, parenPos);
        thenExpr = StringSub(sexpr, parenPos, thenEnd);
        parenPos = thenEnd + 1;
    }
    else {
        thenStart = parenPos;
        parenPos = ReadUntilDelimiter(sexpr, parenPos);
        thenExpr = StringSub(sexpr, thenStart, parenPos - 1);
    }
    
    // Check for else expression
    parenPos = SkipWhitespace(sexpr, parenPos);
    if (parenPos < StringLength(sexpr) && StringSub(sexpr, parenPos, parenPos) != ")") {
        if (StringSub(sexpr, parenPos, parenPos) == "(") {
            elseEnd = FindMatchingParen(sexpr, parenPos);
            elseExpr = StringSub(sexpr, parenPos, elseEnd);
        }
        else {
            elseStart = parenPos;
            parenPos = ReadUntilDelimiter(sexpr, parenPos);
            elseExpr = StringSub(sexpr, elseStart, parenPos - 1);
        }
    }
    
    // Evaluate appropriate branch
    if (condition) {
        // Log("  If condition true, evaluating: " + thenExpr);
        EvalExpression(thenExpr, player, startLocation);
        return "true";
    }
    else if (StringLength(elseExpr) > 0) {
        // Log("  If condition false, evaluating: " + elseExpr);
        EvalExpression(elseExpr, player, startLocation);
        return "false";
    }
    
    return "false";
}

// Call a user-defined function
void CallFunction(string funcName, string argsStr, int player, point startLocation)
{
    int funcIdx;
    string params;
    string body;
    int numParams;
    int numArgs;
    int i;
    string paramName;
    string argValue;
    int oldSymbolCount;
    
    funcIdx = LookupFunction(funcName);
    if (funcIdx == -1) {
        Log("  ERROR: Undefined function: " + funcName);
        return;
    }
    
    // Check recursion depth
    gv_recursionDepth = gv_recursionDepth + 1;
    // Log("  Recursion depth: " + IntToString(gv_recursionDepth));
    if (gv_recursionDepth > c_maxRecursionDepth) {
        Log("  ERROR: Max recursion depth exceeded");
        gv_recursionDepth = gv_recursionDepth - 1;
        return;
    }
    
    params = gv_functionParams[funcIdx];
    body = gv_functionBodies[funcIdx];
    
    // Log("  Calling function: " + funcName + " with args: " + argsStr);
    
    // Save current symbol table size
    oldSymbolCount = gv_symbolCount;
    // Log("  Saved symbol count: " + IntToString(oldSymbolCount));
    
    // Bind parameters to arguments
    numParams = CountTokens(params, " ");
    numArgs = CountTokens(argsStr, " ");
    // Log("  Binding " + IntToString(numParams) + " params to " + IntToString(numArgs) + " args");
    
    i = 0;
    while (i < numParams && i < numArgs) {
        paramName = GetToken(params, " ", i);
        argValue = GetToken(argsStr, " ", i);
        
        // Arguments are already evaluated, just bind them
        DefineVariable(paramName, Trim(argValue));
        // Log("    Bound parameter: " + paramName + " = " + argValue);
        
        i = i + 1;
    }
    
    // Evaluate function body (may contain multiple expressions)
    // Log("  Evaluating body: " + body);
    EvalLisp(body, player, startLocation);
    
    // Restore symbol table (pop local variables)
    gv_symbolCount = oldSymbolCount;
    
    gv_recursionDepth = gv_recursionDepth - 1;
}

// Evaluate a general expression (dispatches to appropriate evaluator)
void EvalExpression(string sexpr, int player, point startLocation)
{
    string command;
    int funcIdx;
    string argsStr;
    int numTokens;
    int i;
    string arg;
    
    sexpr = Trim(sexpr);
    
    if (!StartsWith(sexpr, "(")) {
        // Not an s-expression, probably a variable or literal
        return;
    }
    
    command = GetSExprToken(sexpr, 0);
    
    if (command == "define") {
        EvalDefine(sexpr);
    }
    else if (command == "begin") {
        EvalBegin(sexpr, player, startLocation);
    }
    else if (command == "log") {
        EvalLog(sexpr);
    }
    else if (command == "spawn") {
        EvalSpawn(sexpr, player, startLocation);
    }
    else if (command == "if") {
        EvalIf(sexpr, player, startLocation);
    }
    else if (command == "+" || command == "-" || command == "*" || command == "/") {
        EvalArithmetic(sexpr);
    }
    else if (command == ">" || command == "<" || command == "=") {
        EvalComparison(sexpr);
    }
    else {
        // Check if it's a function call
        funcIdx = LookupFunction(command);
        if (funcIdx != -1) {
            // Build space-separated args string, evaluating expressions
            numTokens = CountSExprTokens(sexpr);
            argsStr = "";
            i = 1;
            while (i < numTokens) {
                arg = GetSExprToken(sexpr, i);
                
                // Evaluate argument if it's an expression
                arg = Trim(arg);
                if (StartsWith(arg, "(")) {
                    // Evaluate nested expression
                    if (StartsWith(arg, "(+") || StartsWith(arg, "(-") || StartsWith(arg, "(*") || StartsWith(arg, "(/")) {
                        arg = IntToString(EvalArithmetic(arg));
                    }
                    else if (StartsWith(arg, "(>") || StartsWith(arg, "(<") || StartsWith(arg, "(=")) {
                        if (EvalComparison(arg)) {
                            arg = "1";
                        }
                        else {
                            arg = "0";
                        }
                    }
                    // Other expressions could be function calls or other forms
                }
                else {
                    // Look up variable value
                    arg = LookupVariable(arg);
                }
                
                if (i > 1) {
                    argsStr = argsStr + " ";
                }
                argsStr = argsStr + arg;
                i = i + 1;
            }
            
            CallFunction(command, argsStr, player, startLocation);
        }
        else {
            Log("WARNING: Unknown command or function: " + command);
        }
    }
}

// Evaluate all s-expressions in a string
void EvalLisp(string code, int player, point startLocation)
{
    int pos;
    int parenStart;
    int parenEnd;
    int len;
    string ch;
    string sexpr;
    
    len = StringLength(code);
    pos = 1;
    
    // Log("=== Evaluating Lisp code ===");
    
    while (pos <= len) {
        // Skip whitespace
        pos = SkipWhitespace(code, pos);
        
        if (pos > len) {
            break;
        }
        
        ch = StringSub(code, pos, pos);
        
        if (ch == "(") {
            // Found start of s-expression
            parenStart = pos;
            parenEnd = FindMatchingParen(code, parenStart);
            
            if (parenEnd == -1) {
                Log("ERROR: Unmatched opening paren at position " + IntToString(pos));
                return;
            }
            
            // Extract the s-expression
            sexpr = StringSub(code, parenStart, parenEnd);
            
            // Evaluate the expression
            EvalExpression(sexpr, player, startLocation);
            
            pos = parenEnd + 1;
        }
        else {
            // Unexpected character
            Log("WARNING: Unexpected character at position " + IntToString(pos) + ": '" + ch + "'");
            pos = pos + 1;
        }
    }
    
    //Log("=== Lisp evaluation complete ===");
}
